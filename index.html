<!doctype html>
<!--
Copyright 2021 The Immersive Web Community Group

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <link rel='stylesheet' href='css/common.css'>
    <link rel='stylesheet' href='css/main.css'>
    <link rel='stylesheet' href='css/drawing.css'>
    <link rel='stylesheet' href='css/coordinates.css'>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        --glass-bg: rgba(255, 255, 255, 0.1);
        --glass-border: rgba(255, 255, 255, 0.2);
        --text-primary: #ffffff;
        --text-secondary: #e0e6ed;
        --shadow-soft: 0 8px 32px rgba(31, 38, 135, 0.37);
        --shadow-strong: 0 20px 40px rgba(0, 0, 0, 0.3);
        --border-radius: 20px;
        --border-radius-sm: 12px;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Poppins', sans-serif;
        background: var(--primary-gradient);
        min-height: 100vh;
        color: var(--text-primary);
        overflow-x: hidden;
      }

      /* Animated background particles */
      body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
          radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%);
        animation: float 6s ease-in-out infinite;
        z-index: -1;
      }

      @keyframes float {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-20px); }
      }

      header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        padding: 20px;
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        border-bottom: 1px solid var(--glass-border);
        box-shadow: var(--shadow-soft);
      }

      .app-header {
        max-width: 1200px;
        margin: 0 auto;
      }

      .header-top {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .app-title {
        font-size: 28px;
        font-weight: 700;
        background: linear-gradient(45deg, #fff, #f0f8ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 2px 10px rgba(255, 255, 255, 0.3);
      }

      .back-button {
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        color: var(--text-primary);
        padding: 8px 16px;
        border-radius: var(--border-radius-sm);
        text-decoration: none;
        font-weight: 500;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }

      .back-button:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .tagline {
        font-size: 16px;
        color: var(--text-secondary);
        font-weight: 300;
        margin-bottom: 20px;
        line-height: 1.5;
      }

      .status-container {
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        border-radius: var(--border-radius);
        padding: 20px;
        margin-bottom: 15px;
        backdrop-filter: blur(20px);
        transition: all 0.3s ease;
      }

      .status-container:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-2px);
        box-shadow: var(--shadow-strong);
      }

      #status-message {
        font-size: 16px;
        font-weight: 500;
        color: var(--text-primary);
        display: flex;
        align-items: center;
        gap: 10px;
      }

      #status-message::before {
        content: 'üìç';
        font-size: 20px;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.1); }
      }

      .controls-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }

      .control-group {
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        border-radius: var(--border-radius);
        padding: 20px;
        backdrop-filter: blur(20px);
        transition: all 0.3s ease;
      }

      .control-group:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-3px);
        box-shadow: var(--shadow-strong);
      }

      .control-label {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-secondary);
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .control-select {
        width: 100%;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--glass-border);
        border-radius: var(--border-radius-sm);
        padding: 12px 16px;
        color: var(--text-primary);
        font-size: 16px;
        font-weight: 500;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }

      .control-select:focus {
        outline: none;
        border-color: rgba(255, 255, 255, 0.5);
        background: rgba(255, 255, 255, 0.2);
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
      }

      .control-select option {
        background: #2a2a2a;
        color: white;
      }

      .action-buttons {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
      }

      .btn {
        background: var(--secondary-gradient);
        border: none;
        border-radius: var(--border-radius);
        padding: 15px 25px;
        color: white;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: var(--shadow-soft);
        position: relative;
        overflow: hidden;
        flex: 1;
        min-width: 150px;
      }

      .btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        transition: left 0.5s;
      }

      .btn:hover::before {
        left: 100%;
      }

      .btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
      }

      .btn:active {
        transform: translateY(-1px);
      }

      .btn-primary {
        background: var(--success-gradient);
      }

      .btn-secondary {
        background: var(--primary-gradient);
      }

      #coordinates-display {
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        border-radius: var(--border-radius);
        padding: 20px;
        backdrop-filter: blur(20px);
        margin-top: 15px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        line-height: 1.6;
        max-height: 200px;
        overflow-y: auto;
      }

      #coordinates-display::-webkit-scrollbar {
        width: 6px;
      }

      #coordinates-display::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
      }

      #coordinates-display::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 3px;
      }

      #coordinates-display strong {
        color: #4facfe;
        font-weight: 600;
      }

      /* WebXR Button Styling */
      .xr-button {
        background: var(--success-gradient) !important;
        border: none !important;
        border-radius: var(--border-radius) !important;
        padding: 15px 30px !important;
        color: white !important;
        font-size: 18px !important;
        font-weight: 700 !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        box-shadow: var(--shadow-soft) !important;
        margin-top: 20px !important;
        width: 100% !important;
        text-transform: uppercase !important;
        letter-spacing: 1px !important;
      }

      .xr-button:hover {
        transform: translateY(-3px) !important;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4) !important;
      }

      .xr-button:disabled {
        background: rgba(255, 255, 255, 0.2) !important;
        cursor: not-allowed !important;
        transform: none !important;
      }

      /* Mobile responsiveness */
      @media (max-width: 768px) {
        header {
          padding: 15px;
        }

        .app-title {
          font-size: 24px;
        }

        .tagline {
          font-size: 14px;
        }

        .controls-grid {
          grid-template-columns: 1fr;
          gap: 12px;
        }

        .action-buttons {
          flex-direction: column;
        }

        .btn {
          min-width: auto;
        }

        .control-group {
          padding: 15px;
        }
      }

      /* Loading animation */
      .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      /* Icon animations */
      .icon-bounce {
        animation: iconBounce 2s ease-in-out infinite;
      }

      @keyframes iconBounce {
        0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
        40% { transform: translateY(-5px); }
        60% { transform: translateY(-3px); }
      }

      /* Glassmorphism effects */
      .glass-card {
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(25px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: var(--border-radius);
        box-shadow: 
          0 8px 32px rgba(31, 38, 135, 0.37),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      /* Hover glow effects */
      .glow-on-hover {
        position: relative;
        transition: all 0.3s ease;
      }

      .glow-on-hover:hover {
        box-shadow: 
          0 0 30px rgba(102, 126, 234, 0.5),
          0 8px 32px rgba(31, 38, 135, 0.37);
      }

      /* Message display in AR */
      .ar-text-overlay {
        position: absolute;
        pointer-events: none;
        transform-origin: center;
        font-family: 'Poppins', sans-serif;
        font-weight: 600;
        color: white;
        text-shadow: 0 0 3px rgba(0,0,0,0.8), 0 0 5px rgba(0,0,0,0.6);
        padding: 5px;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        border-radius: 10px;
        overflow: hidden;
        white-space: normal;
        word-break: break-word;
        background-color: rgba(0,0,0,0.4);
      }
    </style>
    <title>Placebook, No Relation</title>
  </head>
  <body>
    <header>
      <div class="app-header">
        <div class="header-top">
          <h1 class="app-title">Placebook AR</h1>
        </div>
        
        <p class="tagline">
          üåü Turn the world into a living AR canvas. Place digital art at real-world locations for others to discover!
        </p>
        
        <div class="status-container glow-on-hover">
          <div id="status-message">Waiting for GPS...</div>
        </div>
        
        <div class="controls-grid">
          <div class="control-group glass-card" id="audience-control">
            <div class="control-label">üë• Audience</div>
            <select id="audience-selector" class="control-select">
              <option value="public" selected>üåç Everyone (Public)</option>
              <option value="friends">üë´ Friends Only</option>
            </select>
          </div>
          
          <div class="control-group glass-card" id="art-type-control">
            <div class="control-label">üé® Art Type</div>
            <select id="art-type-selector" class="control-select">
              <option value="flower" selected>üåª Flower</option>
              <option value="message">üí¨ Text Message</option>
              <option value="painting">üé≠ Painting</option>
              <option value="drawing">‚úèÔ∏è Drawing</option>
            </select>
          </div>
        </div>
        
        <div class="action-buttons">
          <button class="btn btn-primary" id="refresh-btn">
            üîÑ Refresh GPS Art
          </button>
          <button class="btn btn-secondary" id="draw-btn">
            ‚ú® Draw & Place
          </button>
        </div>
        
        <div id="coordinates-display" class="glass-card"></div>
      </div>
    </header>
    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Node} from './js/render/core/node.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {DropShadowNode} from './js/render/nodes/drop-shadow.js';
      import {vec3} from './js/render/math/gl-matrix.js';
      import {Ray} from './js/render/math/ray.js';
      import {Texture} from './js/render/core/texture.js';
      import {Material} from './js/render/core/material.js';
      import {Mesh} from './js/render/core/mesh.js';
      import {geoService} from './js/geolocation.js';
      import {flowerDB} from './js/database.js';
      import './js/drawing.js'; // Import for side effects only (creates global DrawingManager)
      import {setupEventListeners} from './server/setupEventListeners.js';
      
      // Call setupEventListeners when DOM is loaded
      document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM loaded, setting up event listeners');
        setupEventListeners();
      });
      
      // Also call immediately in case DOM is already loaded
      if (document.readyState === 'interactive' || document.readyState === 'complete') {
        console.log('DOM already loaded, setting up event listeners now');
        setupEventListeners();
      }

      // XR globals.
      let xrButton = null;
      let xrRefSpace = null;
      let xrViewerSpace = null;
      let xrHitTestSource = null;
      
      // Debug variables
      // Note: frameCounter and lastLogTime are declared later in the file
      
      // Global variables
      let currentPosition = null;
      let nearbyFlowers = [];
      let nearbyDrawings = [];
      let pendingDrawing = null;
      let gpsInitialized = false; // Added missing variable declaration
      const GPS_UPDATE_INTERVAL = 10000; // 10 seconds
      const NEARBY_THRESHOLD = 20; // 20 meters

      // WebGL scene globals.
      let gl = null;
      let renderer = null;
      let scene = new Scene();
      scene.enableStats(false);

      let arObject = new Node();
      arObject.visible = false;
      scene.addNode(arObject);

      let flower = new Gltf2Node({url: 'media/gltf/sunflower/sunflower.gltf'});
      arObject.addNode(flower);

      let reticle = new Gltf2Node({url: 'media/gltf/reticle/reticle.gltf'});
      reticle.visible = false;
      scene.addNode(reticle);
      let reticleHitTestResult = null;

      // Having a really simple drop shadow underneath an object helps ground
      // it in the world without adding much complexity.
      let shadow = new DropShadowNode();
      vec3.set(shadow.scale, 0.15, 0.15, 0.15);
      arObject.addNode(shadow);

      const MAX_FLOWERS = 30;
      let flowers = [];

      // Ensure the background is transparent for AR.
      scene.clear = false;

      // Update status message
      function updateStatusMessage(message) {
        const statusElement = document.getElementById('status-message');
        if (statusElement) {
          statusElement.textContent = message;
        }
      }
      
      // Initialize geolocation
      async function initGPS() {
        updateStatusMessage('Requesting GPS permission...');
        
        if (!geoService.isAvailable()) {
          updateStatusMessage('GPS not available on this device');
          return false;
        }
        
        try {
          const permissionGranted = await geoService.requestPermission();
          if (!permissionGranted) {
            updateStatusMessage('GPS permission denied');
            return false;
          }
          
          geoService.startWatching();
          geoService.addPositionListener(handlePositionUpdate);
          
          // Get initial position
          currentPosition = geoService.getLastPosition();
          if (currentPosition) {
            updateStatusMessage(`GPS active: ${currentPosition.coords.latitude.toFixed(6)}, ${currentPosition.coords.longitude.toFixed(6)}`);
            loadNearbyFlowers();
          } else {
            updateStatusMessage('Waiting for GPS signal...');
          }
          
          gpsInitialized = true;
          initXR();
          return true;
        } catch (error) {
          console.error('[GPS] Error initializing GPS:', error);
          updateStatusMessage('Error initializing GPS');
          return false;
        }
      }
      
      // Handle position updates
      function handlePositionUpdate(position) {
        currentPosition = position;
        updateStatusMessage(`GPS: ${position.coords.latitude.toFixed(6)}, ${position.coords.longitude.toFixed(6)}`);
        loadNearbyFlowers();
        updateCoordinatesDisplay();
      }
      
      // Update the coordinates display at the bottom of the screen
      function updateCoordinatesDisplay() {
        const coordsElement = document.getElementById('coordinates-display');
        if (!coordsElement) return;
        
        // Clear previous content
        coordsElement.innerHTML = '';
        
        // Add current position
        if (currentPosition) {
          const currentPosElement = document.createElement('div');
          currentPosElement.innerHTML = `<strong>Your Position:</strong> ${currentPosition.coords.latitude.toFixed(6)}, ${currentPosition.coords.longitude.toFixed(6)}, Alt: ${currentPosition.coords.altitude ? currentPosition.coords.altitude.toFixed(2) + 'm' : 'N/A'}`;
          coordsElement.appendChild(currentPosElement);
        }
        
        // Add flower positions
        if (anchoredObjects && anchoredObjects.length > 0) {
          const flowersList = document.createElement('div');
          flowersList.innerHTML = '<strong>Flower Locations:</strong> ';
          
          let count = 0;
          for (const obj of anchoredObjects) {
            if (obj.isGpsFlower && obj.gpsData) {
              count++;
              const flowerElement = document.createElement('div');
              flowerElement.textContent = `Flower ${count}: ${obj.gpsData.latitude.toFixed(6)}, ${obj.gpsData.longitude.toFixed(6)}`;
              flowersList.appendChild(flowerElement);
            }
          }
          
          if (count > 0) {
            coordsElement.appendChild(flowersList);
          }
        }
      }
      
      // Load nearby flowers based on current position
      async function loadNearbyFlowers() {
        if (!currentPosition) {
          console.log('[GPS] No position available yet');
          return;
        }
        
        try {
          // Get nearby flowers from server
          nearbyFlowers = await flowerDB.getNearbyFlowers(currentPosition, NEARBY_THRESHOLD);
          
          // Ensure nearbyFlowers is always an array
          if (!nearbyFlowers || !Array.isArray(nearbyFlowers)) {
            console.warn('[GPS] Server returned invalid data, using empty array');
            nearbyFlowers = [];
          }
          
          console.log(`[GPS] Found ${nearbyFlowers.length} nearby flowers`);
          
          // Update status with flower count
          updateStatusMessage(`GPS: ${currentPosition.coords.latitude.toFixed(6)}, ${currentPosition.coords.longitude.toFixed(6)} | Nearby flowers: ${nearbyFlowers.length}`);
          
          // Update the scene with the nearby flowers
          updateFlowersInScene();
        } catch (error) {
          console.error('[GPS] Error loading nearby flowers:', error);
          updateStatusMessage('Error loading nearby flowers. Check console for details.');
          // Ensure nearbyFlowers is an empty array on error
          nearbyFlowers = [];
        }
      }
      
      // Update the scene with nearby art objects
      function updateFlowersInScene() {
        // Clear existing GPS-based art objects (not user-placed ones)
        for (const obj of anchoredObjects) {
          if (obj.isGpsArt) {
            scene.removeNode(obj.anchoredObject);
          }
        }
        
        // Filter to keep only user-placed art objects
        anchoredObjects = anchoredObjects.filter(obj => !obj.isGpsArt);
        
        // Add nearby GPS art objects to the scene
        for (const artData of nearbyFlowers) {
          let artObject;
          
          // Create appropriate 3D object based on art type
          switch(artData.artType || 'flower') {
            case 'message':
              // Create a text node for messages
              artObject = new XRNode();
              
              // Create text element (using a simple cube as placeholder)
              const textBox = new Cube({size: 0.15});
              textBox.material = new SolidColorMaterial();
              textBox.material.baseColor = [0.9, 0.9, 0.5, 1.0]; // Light yellow
              
              artObject.addNode(textBox);
              
              // Scale appropriately
              artObject.scale = [1, 0.5, 0.1];
              break;
              
            case 'painting':
              // Create a painting object (flat surface)
              artObject = new XRNode();
              
              // Create painting surface (using a simple cube as placeholder)
              const canvas = new Cube({size: 0.2});
              canvas.material = new SolidColorMaterial();
              canvas.material.baseColor = [1, 1, 1, 1]; // White canvas
              
              artObject.addNode(canvas);
              
              // Scale to be flat like a canvas
              artObject.scale = [1.5, 1.5, 0.05];
              break;
              
            case 'drawing':
              // Create a drawing object
              artObject = new XRNode();
              
              // Create drawing surface (using a simple cube as placeholder)
              const drawingSurface = new Cube({size: 0.15});
              drawingSurface.material = new SolidColorMaterial();
              drawingSurface.material.baseColor = [0.8, 0.8, 0.9, 1.0]; // Light blue
              
              artObject.addNode(drawingSurface);
              
              // Scale appropriately
              artObject.scale = [1, 1, 0.05];
              break;
              
            case 'flower':
            default:
              // Default to flower
              artObject = new Gltf2Node({url: 'media/gltf/sunflower/sunflower.gltf'});
              artObject.scale = [0.3, 0.3, 0.3];
          }
          
          // Set the matrix from stored data
          if (artData.matrix) {
            artObject.matrix = new Float32Array(artData.matrix);
          }
          
          scene.addNode(artObject);
          
          // Add to anchored objects with GPS flag
          anchoredObjects.push({
            anchoredObject: artObject,
            anchor: null, // No XR anchor for GPS art
            isGpsArt: true,
            gpsData: artData
          });
          
          // Update coordinates display when adding art objects
          updateCoordinatesDisplay();
        }
        
        console.log(`[GPS] Scene updated with ${nearbyFlowers.length} GPS flowers`);
      }
      
      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: 'ü•Ω ENTER VR EXPERIENCE', // More descriptive text
          textExitXRTitle: 'üö™ EXIT VR EXPERIENCE',
          height: 60 // Larger button
        });
        
        // Create a special container for the XR button for better positioning
        const xrContainer = document.createElement('div');
        xrContainer.className = 'xr-button-container';
        xrContainer.style.cssText = `
          position: fixed;
          bottom: 30px;
          left: 50%;
          transform: translateX(-50%);
          z-index: 1000;
          display: flex;
          justify-content: center;
          align-items: center;
          padding: 10px;
          border-radius: 12px;
          background: rgba(0, 0, 0, 0.2);
          backdrop-filter: blur(5px);
          box-shadow: 0 8px 32px rgba(31, 38, 135, 0.2);
        `;
        
        xrContainer.appendChild(xrButton.domElement);
        document.body.appendChild(xrContainer);
        
        // Add a pulsing animation to draw attention
        const style = document.createElement('style');
        style.textContent = `
          @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
          }
          .xr-button-container {
            animation: pulse 2s infinite ease-in-out;
          }
        `;
        document.head.appendChild(style);
        
        // Add instruction text above the button
        const instructionEl = document.createElement('div');
        instructionEl.textContent = 'Click to experience in Virtual Reality';
        instructionEl.style.cssText = `
          position: absolute;
          top: -30px;
          left: 50%;
          transform: translateX(-50%);
          color: white;
          text-shadow: 0 0 5px rgba(0,0,0,0.5);
          font-weight: bold;
          white-space: nowrap;
        `;
        xrContainer.appendChild(instructionEl);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar')
              .then((supported) => {
                xrButton.enabled = supported;
              });
        }
        
        // Listen for drawing completion event
        document.addEventListener('drawingComplete', (event) => {
          console.log('Drawing completed, ready to place in AR');
          pendingDrawing = event.detail.drawingData;
          updateStatusMessage('Drawing ready! Tap to place it');
        });
      }

      function onRequestSession() {
        console.log("[DEBUG] Requesting AR session with hit-test and anchors");
        return navigator.xr.requestSession('immersive-ar', {requiredFeatures: ['local', 'hit-test', 'anchors']})
                           .then((session) => {
          console.log("[DEBUG] AR session created successfully");
          xrButton.setSession(session);
          onSessionStarted(session);
        }).catch(error => {
          console.error(`[DEBUG] Error creating AR session: ${error.message}`);
        });
      }

      function onSessionStarted(session) {
        console.log("[DEBUG] Session started");
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);

        // Add additional event listeners for better debugging
        session.addEventListener('inputsourceschange', (event) => {
          console.log(`[DEBUG] Input sources changed: ${event.added.length} added, ${event.removed.length} removed`);
        });

        if (!gl) {
          console.log("[DEBUG] Creating WebGL context");
          gl = createWebGLContext({
            xrCompatible: true
          });

          renderer = new Renderer(gl);
          console.log(`[DEBUG] Renderer created: ${renderer !== null}`);

          scene.setRenderer(renderer);
        }

        console.log("[DEBUG] Updating render state");
        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

        // In this sample we want to cast a ray straight out from the viewer's
        // position and render a reticle where it intersects with a real world
        // surface. To do this we first get the viewer space, then create a
        // hitTestSource that tracks it.
        console.log("[DEBUG] Requesting viewer reference space");
        session.requestReferenceSpace('viewer').then((refSpace) => {
          console.log("[DEBUG] Viewer reference space acquired");
          xrViewerSpace = refSpace;
          console.log("[DEBUG] Requesting hit test source");
          session.requestHitTestSource({ space: xrViewerSpace }).then((hitTestSource) => {
            console.log("[DEBUG] Hit test source acquired");
            xrHitTestSource = hitTestSource;
          }).catch(error => {
            console.error(`[DEBUG] Error creating hit test source: ${error.message}`);
          });
        }).catch(error => {
          console.error(`[DEBUG] Error getting viewer space: ${error.message}`);
        });

        console.log("[DEBUG] Requesting local reference space");
        session.requestReferenceSpace('local').then((refSpace) => {
          console.log("[DEBUG] Local reference space acquired");
          xrRefSpace = refSpace;

          session.requestAnimationFrame(onXRFrame);
        }).catch(error => {
          console.error(`[DEBUG] Error getting local space: ${error.message}`);
        });
      }

      function onEndSession(session) {
        // Use proper array methods instead of clear() which doesn't exist on arrays
        anchoredObjects = [];
        xrHitTestSource.cancel();
        xrHitTestSource = null;
        session.end();
      }

      function onSessionEnded(event) {
        xrButton.setSession(null);
      }

      const MAX_ANCHORED_OBJECTS = 30;
      let anchoredObjects = [];
      function addAnchoredObjectsToScene(anchor, artType = 'flower', artData = {}) {
        console.log(`[DEBUG] Adding anchored ${artType} to scene`);
        
        let artObject;
        
        // Create the appropriate 3D object based on art type
        switch(artType) {
          case 'message':
            // Create a container node for the message
            artObject = new Node();
            
            // Add a cube as background/holder for the message
            const cubeNode = new Gltf2Node({url: 'media/gltf/cube/cube.gltf'});
            cubeNode.scale = [0.25, 0.15, 0.02]; // Make it flat like a sign
            artObject.addNode(cubeNode);
            
            // Store the message text for reference
            const messageText = artData.text || 'No text';
            artObject.messageText = messageText;
            
            // Create a visible text display using HTML and CSS
            const textDisplay = document.createElement('div');
            textDisplay.innerText = messageText;
            textDisplay.style.position = 'absolute';
            textDisplay.style.backgroundColor = 'white';
            textDisplay.style.color = 'black';
            textDisplay.style.padding = '5px';
            textDisplay.style.borderRadius = '5px';
            textDisplay.style.fontWeight = 'bold';
            textDisplay.style.zIndex = '1000';
            textDisplay.style.pointerEvents = 'none'; // Don't interfere with AR interactions
            textDisplay.classList.add('ar-text-label');
            
            // Store DOM element reference for positioning updates
            artObject.textElement = textDisplay;
            document.body.appendChild(textDisplay);
            
            // Visibility will be managed in the render loop
            textDisplay.style.display = 'none';
            break;
            
          case 'painting':
            // Create a painting object (using cube as placeholder)
            artObject = new Gltf2Node({url: 'media/gltf/cube/cube.gltf'}); 
            artObject.scale = [0.3, 0.3, 0.02]; // Flat like a canvas
            break;
            
          case 'drawing':
            // Create a drawing object (using cube as placeholder)
            artObject = new Gltf2Node({url: 'media/gltf/cube/cube.gltf'});
            artObject.scale = [0.2, 0.2, 0.02]; // Flat surface
            break;
            
          case 'flower':
          default:
            // Default to flower
            artObject = new Gltf2Node({url: 'media/gltf/sunflower/sunflower.gltf'});
            artObject.scale = [0.3, 0.3, 0.3];
        }
        // Add the art object to the scene
        scene.addNode(artObject);
        
        // Track the art object with its anchor and metadata
        anchoredObjects.push({
          anchoredObject: artObject,
          anchor: anchor,
          artType: artType,
          artData: artData
        });

        console.log(`[DEBUG] ${artType} added, total anchored objects: ${anchoredObjects.length}`);

        // For performance reasons if we add too many objects start
        // removing the oldest ones to keep the scene complexity
        // from growing too much.
        if (anchoredObjects.length > MAX_ANCHORED_OBJECTS) {
          // Find the oldest non-GPS flower to remove
          const index = anchoredObjects.findIndex(obj => !obj.isGpsFlower);
          if (index !== -1) {
            let objectToRemove = anchoredObjects.splice(index, 1)[0];
            scene.removeNode(objectToRemove.anchoredObject);
            if (objectToRemove.anchor) {
              objectToRemove.anchor.delete();
            }
            console.log("[DEBUG] Removed oldest flower due to limit");
          }
        }
      }

      let rayOrigin = vec3.create();
      let rayDirection = vec3.create();
      function onSelect(event) {
        console.log("[DEBUG] onSelect called");
        console.log(`[DEBUG] Reticle visible: ${reticle.visible}`);

        if (reticle.visible) {
          console.log("[DEBUG] Creating anchor from hit test result");
          // Create an anchor.
          reticleHitTestResult.createAnchor().then(async (anchor) => {
            console.log("[DEBUG] Anchor created successfully");
            
            // Check if we have a pending drawing to place
            if (pendingDrawing) {
              console.log("[DEBUG] Placing drawing at hit location");
              
              // IMPORTANT: Always create and add the drawing node first, regardless of GPS
              // This ensures the drawing is visible in AR even without GPS
              const drawingNode = await addDrawingToScene(anchor, pendingDrawing);
              console.log("[DEBUG] Drawing node created:", drawingNode ? "success" : "failed");
              
              if (drawingNode) {
                console.log("[DEBUG] Drawing node added to scene successfully");
                
                // Try to save with GPS if available, but don't block placement
                try {
                  if (currentPosition) {
                    // If GPS is available, save with coordinates
                    const drawingData = {
                      latitude: currentPosition.coords.latitude,
                      longitude: currentPosition.coords.longitude,
                      altitude: currentPosition.coords.altitude || 0,
                      imageData: pendingDrawing,
                      timestamp: new Date().toISOString()
                    };
                    
                    // Save drawing to server
                    await saveDrawingToServer(drawingData);
                    console.log(`[GPS] Drawing saved at ${drawingData.latitude}, ${drawingData.longitude}`);
                    updateStatusMessage('Drawing placed and saved with GPS coordinates!');
                    
                    // Refresh nearby drawings (async)
                    await loadNearbyDrawings();
                  } else {
                    // No GPS, but drawing is already placed locally
                    console.log("[DEBUG] Drawing placed locally only (no GPS)");
                    updateStatusMessage('Drawing placed locally (GPS not available)');
                  }
                  
                  // Clear the pending drawing in either case
                  pendingDrawing = null;
                } catch (error) {
                  console.error('[DEBUG] Error handling drawing placement:', error);
                  updateStatusMessage('Drawing placed locally only.');
                  pendingDrawing = null;
                }
              } else {
                console.error("[DEBUG] Failed to create drawing node");
                updateStatusMessage("Error creating drawing. Please try again.");
                pendingDrawing = null; // Clear pending drawing on error
              }
            } else {
              // Check if GPS is available before placing art
              if (currentPosition) {
                // Save the art with GPS coordinates to server
                const pose = reticleHitTestResult.getPose(xrRefSpace);
                
                // Get the selected audience and art type from the UI
                const audienceSelector = document.getElementById('audience-selector');
                const audience = audienceSelector ? audienceSelector.value : 'public';
                
                const artTypeSelector = document.getElementById('art-type-selector');
                const artType = artTypeSelector ? artTypeSelector.value : 'flower';
                
                // Prepare additional art data based on type
                let artData = {};
                
                // For message type, prompt for text content
                if (artType === 'message') {
                  const messageText = prompt('Enter your message:', '');
                  if (messageText) {
                    artData = { text: messageText };
                  } else {
                    updateStatusMessage('Message canceled');
                    return; // Exit if user cancels message input
                  }
                }
                
                // Save the art with GPS data
                flowerDB.saveArt(currentPosition, Array.from(pose.transform.matrix), audience, artType, artData)
                  .then(savedArt => {
                    console.log(`[GPS] ${savedArt.artType} saved with ID: ${savedArt.id}, audience: ${savedArt.audience}`);
                    updateStatusMessage(`${savedArt.artType} placed and saved to the cloud (${savedArt.audience})!`);
                  })
                  .catch(error => {
                    console.error('[GPS] Error saving art:', error);
                    updateStatusMessage('Error saving art to the cloud');
                  });
                
                // Add the art object to the scene
                addAnchoredObjectsToScene(anchor, artType, artData);
              } else {
                console.log("[GPS] GPS not available, placing local art only");
                updateStatusMessage("GPS not available, placing local art only");
                
                // Get art type for local placement
                const artTypeSelector = document.getElementById('art-type-selector');
                const artType = artTypeSelector ? artTypeSelector.value : 'flower';
                
                // Add the art to the scene locally
                addAnchoredObjectsToScene(anchor, artType);
              }
            }
          }).catch((error) => {
            console.error("[DEBUG] Could not create anchor: " + error);
            updateStatusMessage("Could not place object: " + error);
          });
        } else {
          console.log("[DEBUG] Reticle not visible, cannot place object");
          updateStatusMessage("Point at a surface to place an object");
        }
      }

      // Debug counter to track frame rendering
      let frameCounter = 0;
      let lastLogTime = 0;

      // Called every time a XRSession requests that a new frame be drawn.
      function onXRFrame(t, frame) {
        frameCounter++;

        // Log debug info every 60 frames (approximately once per second)
        const shouldLog = (t - lastLogTime) > 1000;
        if (shouldLog) {
          console.log(`[DEBUG] Frame ${frameCounter} at time ${t.toFixed(2)}ms`);
          lastLogTime = t;
        }

        let session = frame.session;
        let pose = frame.getViewerPose(xrRefSpace);

        // Debug pose information
        if (shouldLog) {
          console.log(`[DEBUG] Pose available: ${pose !== null}`);
          console.log(`[DEBUG] GL context lost: ${gl.isContextLost()}`);
          console.log(`[DEBUG] Anchored objects: ${anchoredObjects.length}`);
        }

        reticle.visible = false;

        // If we have a hit test source, get its results for the frame
        // and use the pose to display a reticle in the scene.
        if (xrHitTestSource && pose) {
          let hitTestResults = frame.getHitTestResults(xrHitTestSource);
          if (shouldLog) {
            console.log(`[DEBUG] Hit test results: ${hitTestResults.length}`);
          }

          if (hitTestResults.length > 0) {
            let pose = hitTestResults[0].getPose(xrRefSpace);
            reticle.visible = true;
            reticle.matrix = pose.transform.matrix;
            reticleHitTestResult = hitTestResults[0];

            if (shouldLog) {
              console.log(`[DEBUG] Reticle visible: ${reticle.visible}`);
              console.log(`[DEBUG] Reticle matrix: ${reticle.matrix[0].toFixed(2)},${reticle.matrix[5].toFixed(2)},${reticle.matrix[10].toFixed(2)}`);
            }
          }
        }

        // Debug tracked anchors
        if (shouldLog) {
          console.log(`[DEBUG] Tracked anchors: ${frame.trackedAnchors ? frame.trackedAnchors.size : 'N/A'}`);
        }

        for (const {anchoredObject, anchor} of anchoredObjects) {
          // only update the object's position if it's still in the list
          // of frame.trackedAnchors and the anchor is valid
          if (!frame.trackedAnchors || !anchor || !frame.trackedAnchors.has(anchor)) {
            continue;
          }
          const anchorPose = frame.getPose(anchor.anchorSpace, xrRefSpace);
          if (anchorPose) {
            anchoredObject.matrix = anchorPose.transform.matrix;
            
            // If this is a message art type with a text element, update its position
            if (anchoredObject.artType === 'message' && anchoredObject.textElement) {
              // Get the 3D position of the anchor in the scene
              const positionMatrix = anchorPose.transform.matrix;
              
              // Project the 3D position to 2D screen coordinates
              const viewMatrix = view.transform.inverse.matrix;
              const projectionMatrix = view.projectionMatrix;
              
              // Calculate position in clip space
              const position = vec3.fromValues(
                positionMatrix[12], 
                positionMatrix[13] + 0.1, // Add a small offset to position text above the cube
                positionMatrix[14]
              );
              
              // Convert to NDC
              const worldPos = vec3.create();
              vec3.transformMat4(worldPos, position, viewMatrix);
              vec3.transformMat4(worldPos, worldPos, projectionMatrix);
              
              // Convert to screen space
              if (worldPos[2] < 0) {
                // Object is behind the camera, hide the text
                anchoredObject.textElement.style.display = 'none';
              } else {
                // Calculate screen position (in pixels)
                const canvasWidth = gl.canvas.width;
                const canvasHeight = gl.canvas.height;
                
                const screenX = (worldPos[0] / worldPos[2] + 1) * 0.5 * canvasWidth;
                const screenY = (1 - (worldPos[1] / worldPos[2] + 1) * 0.5) * canvasHeight;
                
                // Update text element position
                anchoredObject.textElement.style.left = `${screenX}px`;
                anchoredObject.textElement.style.top = `${screenY}px`;
                anchoredObject.textElement.style.display = 'block';
                
                // Optional: Add distance-based sizing for better readability
                const distance = vec3.length(worldPos);
                const scale = Math.max(0.5, Math.min(1.5, 1.0 / distance));
                anchoredObject.textElement.style.transform = `translate(-50%, -50%) scale(${scale})`;
              }
            }
          } else if (shouldLog) {
            console.log(`[DEBUG] No anchor pose for tracked anchor`);
          }
        }

        scene.startFrame();

        // Debug rendering
        if (shouldLog) {
          console.log(`[DEBUG] Before drawXRFrame - renderer ready: ${renderer !== null}`);
        }

        session.requestAnimationFrame(onXRFrame);

        try {
          scene.drawXRFrame(frame, pose);
          if (shouldLog) {
            console.log(`[DEBUG] drawXRFrame completed successfully`);
          }
        } catch (error) {
          console.error(`[DEBUG] Error in drawXRFrame: ${error.message}`);
        }

        scene.endFrame();
      }

      // Add GPS controls to the header
      function addGpsControls() {
        const header = document.querySelector('header');
        
        // Create refresh button
        const refreshButton = document.createElement('button');
        refreshButton.textContent = 'Refresh GPS Flowers';
        refreshButton.addEventListener('click', () => {
          loadNearbyFlowers();
          updateStatusMessage('GPS flowers refreshed');
        });
        
        // Create draw button
        const drawButton = document.createElement('button');
        drawButton.textContent = 'Draw & Place';
        drawButton.addEventListener('click', () => {
          window.DrawingManager.showDrawingUI();
          updateStatusMessage('Drawing mode activated');
        });
        
        // Add buttons to header
        header.appendChild(refreshButton);
        header.appendChild(drawButton);
      }
      
      // Create a plane with the drawing texture
      async function createDrawingPlane(drawingData) {
        console.log("[DEBUG] createDrawingPlane called with data of length:", drawingData ? drawingData.length : 'null');
        
        // Validate drawing data early
        if (!drawingData || !drawingData.startsWith('data:image')) {
          console.error("[DEBUG] Invalid drawing data format:", drawingData ? drawingData.substring(0, 20) : 'null');
          updateStatusMessage("Error: Invalid drawing data format");
          return null; // Return null instead of an empty plane to clearly indicate failure
        }
        
        const plane = new Node();

        // Create a material for the drawing - using a simpler material approach
        const material = new Material();
        
        // Fix rendering order/layer issues
        material.depthTest = false; // Disable depth testing to ensure visibility
        material.blend = true; // Enable transparency
        material.blendFunc = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; // Use ONE for source factor
        material.cullMode = gl.NONE; // Don't cull any faces
        material.renderOrder = 1000; // High render order to ensure it renders on top
        
        // Set material properties for maximum visibility
        material.baseColorFactor = [1.0, 1.0, 1.0, 1.0]; // Full opacity
        material.metallicFactor = 0.0; // Non-metallic
        material.roughnessFactor = 1.0; // Fully rough
        material.emissiveFactor = [1.0, 1.0, 1.0]; // Maximum glow

        // Load the drawing image as a texture
        const texture = await new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            console.log("[DEBUG] Image loaded successfully, dimensions:", img.width, "x", img.height);
            const texture = new Texture(gl, { 
              image: img,
              format: gl.RGBA, // Use RGBA format
              generateMipmaps: true // Generate mipmaps for better rendering
            });
            resolve(texture);
          };
          img.onerror = (error) => {
            console.error("[DEBUG] Failed to load drawing image for texture:", error);
            resolve(null); // Resolve with null on error
          };
          img.src = drawingData;
        });

        if (!texture) {
          console.error("[DEBUG] Could not create texture from drawing data.");
          updateStatusMessage("Error: Could not create drawing texture");
          return null; // Return null instead of an empty plane to clearly indicate failure
        }

        console.log("[DEBUG] Texture created successfully");
        material.baseColorTexture = texture;

        // Create a simpler quad for the drawing
        const mesh = new Mesh(gl, {
          vertices: [
            -1.0, -1.0, 0.0,  // Bottom left
             1.0, -1.0, 0.0,  // Bottom right
             1.0,  1.0, 0.0,  // Top right
            -1.0,  1.0, 0.0,  // Top left
          ],
          texcoords: [
            0.0, 0.0,  // Bottom left
            1.0, 0.0,  // Bottom right
            1.0, 1.0,  // Top right
            0.0, 1.0,  // Top left
          ],
          normals: [
            0.0, 0.0, 1.0,  // All normals point forward
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
          ],
          indices: [0, 1, 2, 0, 2, 3],  // Two triangles forming a quad
          material: material,
        });

        // Create a parent node with proper transformation
        const drawingNode = new Node();
        drawingNode.addNode(mesh);
        
        // Add the drawing node to the plane
        plane.addNode(drawingNode);
        
        // Set renderOrder for the plane to ensure it renders on top
        plane.renderOrder = 1000;
        
        // Log success
        console.log("[DEBUG] Drawing plane created successfully with mesh and texture");

        return plane;
      }
      
      // Save drawing to server
      async function saveDrawingToServer(drawingData) {
        try {
          const response = await fetch(`${flowerDB.apiUrl}/drawings`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(drawingData)
          });
          
          if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
          }
          
          return await response.json();
        } catch (error) {
          console.error('Error saving drawing to server:', error);
          throw error;
        }
      }
      
      // Load nearby drawings based on current position
      async function loadNearbyDrawings() {
        if (!currentPosition) {
          console.log('[GPS] No position available yet for drawings');
          return;
        }
        
        try {
          const response = await fetch(
            `${flowerDB.apiUrl}/drawings/nearby?lat=${currentPosition.coords.latitude}&lng=${currentPosition.coords.longitude}&distance=${NEARBY_THRESHOLD}`
          );
          
          if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
          }
          
          nearbyDrawings = await response.json();
          console.log(`[GPS] Found ${nearbyDrawings.length} nearby drawings`);
          
          // Update the scene with the nearby drawings
          updateDrawingsInScene();
        } catch (error) {
          console.error('[GPS] Error loading nearby drawings:', error);
          nearbyDrawings = [];
        }
      }
      
      // Update the scene with nearby drawings
      async function updateDrawingsInScene() {
        // Clear existing GPS-based drawings
        for (const obj of anchoredObjects) {
          if (obj.isDrawing && obj.isGpsFlower) {
            scene.removeNode(obj.anchoredObject);
          }
        }
        
        // Filter to keep only non-drawing objects or user-placed drawings
        anchoredObjects = anchoredObjects.filter(obj => !obj.isDrawing || !obj.isGpsFlower);
        
        // Add nearby GPS drawings to the scene
        console.log(`[GPS] Adding ${nearbyDrawings.length} nearby drawings to scene`);
        
        // Process drawings one by one to avoid overwhelming the system
        for (const drawingData of nearbyDrawings) {
          try {
            const drawingNode = new Node();
            
            // Create drawing plane with async/await
            console.log('[GPS] Creating drawing plane for nearby drawing');
            const drawingPlane = await createDrawingPlane(drawingData.imageData);
            console.log('[GPS] Drawing plane created successfully');
            
            drawingPlane.scale = [0.2, 0.2, 0.2]; // Scale appropriately
            drawingNode.addNode(drawingPlane);
            scene.addNode(drawingNode);
            
            // Add to anchored objects
            anchoredObjects.push({
              anchoredObject: drawingNode,
              anchor: null, // No XR anchor for GPS-based drawings
              isDrawing: true,
              isGpsFlower: true // This is a GPS-based drawing
            });
          } catch (error) {
            console.error('[GPS] Error creating drawing plane for nearby drawing:', error);
          }
        }
        
        console.log(`[GPS] Scene updated with ${nearbyDrawings.length} GPS drawings`);
      }
      
      // Add event listener for drawing completion
      document.addEventListener('drawingComplete', (event) => {
        console.log('[DEBUG] Drawing complete event received');
        // Store the drawing data for placement
        pendingDrawing = event.detail.drawingData;
        
        // Log the drawing data to verify it's valid
        console.log('[DEBUG] Drawing data received:', pendingDrawing ? pendingDrawing.substring(0, 50) + '...' : 'null');
        
        // Notify user to place the drawing
        updateStatusMessage('Drawing ready! Point at a surface to place it.');
        
        // Log GPS status for debugging
        if (currentPosition) {
          console.log('[DEBUG] GPS is available for drawing placement');
        } else {
          console.log('[DEBUG] GPS is NOT available, but drawing will still be placed locally');
        }
      });
      
      // Function to add a drawing to the scene (similar to addAnchoredObjectsToScene)
      async function addDrawingToScene(anchor, drawingData) {
        console.log("[DEBUG] Adding anchored drawing to scene");
        
        try {
          // Create a drawing node
          const drawingNode = new Node();
          
          // Set high render order for the drawing node
          drawingNode.renderOrder = 2000;
          
          // Create a plane for the drawing
          const drawingPlane = await createDrawingPlane(drawingData);
          if (!drawingPlane) {
            console.error("[DEBUG] Failed to create drawing plane");
            return null;
          }
          
          console.log("[DEBUG] Drawing plane created successfully");
          
          // Make sure the drawing is visible and properly scaled
          drawingPlane.scale = [0.5, 0.5, 0.5]; // Increased scale for better visibility
          
          // Try a different orientation - no rotation
          // This will make the drawing appear flat on the surface
          
          // Add the drawing plane to the drawing node
          drawingNode.addNode(drawingPlane);
          
          // Add the drawing directly to the scene first for visibility testing
          scene.addNode(drawingNode);
          console.log("[DEBUG] Drawing node added to scene");
          
          // Create a simple colored cube as a test marker
          const testCube = new Mesh(gl, {
            vertices: [
              // Front face
              -0.1, -0.1,  0.1,
               0.1, -0.1,  0.1,
               0.1,  0.1,  0.1,
              -0.1,  0.1,  0.1,
              // Back face
              -0.1, -0.1, -0.1,
              -0.1,  0.1, -0.1,
               0.1,  0.1, -0.1,
               0.1, -0.1, -0.1,
            ],
            indices: [
              0, 1, 2,    0, 2, 3, // front
              4, 5, 6,    4, 6, 7, // back
              5, 3, 2,    5, 2, 6, // top
              4, 7, 1,    4, 1, 0, // bottom
              7, 6, 2,    7, 2, 1, // right
              4, 0, 3,    4, 3, 5  // left
            ],
            material: new Material({
              baseColorFactor: [1.0, 0.0, 0.0, 1.0], // Bright red
              depthTest: false, // Disable depth testing for visibility
              blend: true // Enable blending
            })
          });
          
          // Add the test cube to the drawing node
          const testNode = new Node();
          testNode.addNode(testCube);
          testNode.renderOrder = 3000; // Even higher render order
          drawingNode.addNode(testNode);
          console.log("[DEBUG] Test cube added to drawing node");
          
          // Add to anchored objects with specific type
          anchoredObjects.push({
            anchoredObject: drawingNode,
            anchor: anchor,
            isDrawing: true,
            isGpsFlower: false
          });
          
          console.log("[DEBUG] Drawing added to anchored objects array, total count:", anchoredObjects.length);
          console.log("[DEBUG] Drawing added to scene successfully with test cube");
          return drawingNode;
        } catch (error) {
          console.error("[DEBUG] Error adding drawing to scene:", error);
          updateStatusMessage('Error creating drawing. Please try again.');
          return null;
        }
      }

      // Start the application
      initXR();
      addGpsControls();
      
      // Initialize GPS functionality
      initGPS().then(success => {
        if (success) {
          console.log('[DEBUG] GPS initialized successfully');
        } else {
          console.log('[DEBUG] GPS initialization failed');
          updateStatusMessage('GPS unavailable. Some features may be limited.');
        }
      });
    </script>
  </body>
</html>