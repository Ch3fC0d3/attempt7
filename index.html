<!doctype html>
<!--
Copyright 2021 The Immersive Web Community Group

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <link rel='stylesheet' href='css/common.css'>
    <link rel='stylesheet' href='css/main.css'>
    <link rel='stylesheet' href='css/drawing.css'>
    <link rel='stylesheet' href='css/coordinates.css'>

    <title>Location-Based AR Flowers</title>
  </head>
  <body>
    <header>
      <details open>
        <summary>Location-Based AR Flowers</summary>
        <p>
          Place virtual flowers that are tied to your real-world GPS location. Other users at the same location will see the flowers you've placed!
          <a class="back" href="./">Back</a>
        </p>
        <div id="status-message">Waiting for GPS...</div>
        <div id="coordinates-display"></div>
      </details>
    </header>
    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Node} from './js/render/core/node.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {DropShadowNode} from './js/render/nodes/drop-shadow.js';
      import {vec3} from './js/render/math/gl-matrix.js';
      import {Ray} from './js/render/math/ray.js';
      import {Texture} from './js/render/core/texture.js';
      import {Material} from './js/render/core/material.js';
      import {Mesh} from './js/render/core/mesh.js';
      import {geoService} from './js/geolocation.js';
      import {flowerDB} from './js/database.js';
      import './js/drawing.js'; // Import for side effects only (creates global DrawingManager)

      // XR globals.
      let xrButton = null;
      let xrRefSpace = null;
      let xrViewerSpace = null;
      let xrHitTestSource = null;
      
      // Debug variables
      // Note: frameCounter and lastLogTime are declared later in the file
      
      // Global variables
      let currentPosition = null;
      let nearbyFlowers = [];
      let nearbyDrawings = [];
      let pendingDrawing = null;
      let gpsInitialized = false; // Added missing variable declaration
      const GPS_UPDATE_INTERVAL = 10000; // 10 seconds
      const NEARBY_THRESHOLD = 20; // 20 meters

      // WebGL scene globals.
      let gl = null;
      let renderer = null;
      let scene = new Scene();
      scene.enableStats(false);

      let arObject = new Node();
      arObject.visible = false;
      scene.addNode(arObject);

      let flower = new Gltf2Node({url: 'media/gltf/sunflower/sunflower.gltf'});
      arObject.addNode(flower);

      let reticle = new Gltf2Node({url: 'media/gltf/reticle/reticle.gltf'});
      reticle.visible = false;
      scene.addNode(reticle);
      let reticleHitTestResult = null;

      // Having a really simple drop shadow underneath an object helps ground
      // it in the world without adding much complexity.
      let shadow = new DropShadowNode();
      vec3.set(shadow.scale, 0.15, 0.15, 0.15);
      arObject.addNode(shadow);

      const MAX_FLOWERS = 30;
      let flowers = [];

      // Ensure the background is transparent for AR.
      scene.clear = false;

      // Update status message
      function updateStatusMessage(message) {
        const statusElement = document.getElementById('status-message');
        if (statusElement) {
          statusElement.textContent = message;
        }
      }
      
      // Initialize geolocation
      async function initGPS() {
        updateStatusMessage('Requesting GPS permission...');
        
        if (!geoService.isAvailable()) {
          updateStatusMessage('GPS not available on this device');
          return false;
        }
        
        try {
          const permissionGranted = await geoService.requestPermission();
          if (!permissionGranted) {
            updateStatusMessage('GPS permission denied');
            return false;
          }
          
          geoService.startWatching();
          
          // Add position update listener
          geoService.addPositionListener(handlePositionUpdate);
          
          // Get initial position
          currentPosition = geoService.getLastPosition();
          if (currentPosition) {
            updateStatusMessage(`GPS active: ${currentPosition.coords.latitude.toFixed(6)}, ${currentPosition.coords.longitude.toFixed(6)}`);
            loadNearbyFlowers();
          } else {
            updateStatusMessage('Waiting for GPS signal...');
          }
          
          gpsInitialized = true;
          return true;
        } catch (error) {
          console.error('[GPS] Error initializing GPS:', error);
          updateStatusMessage('Error initializing GPS');
          return false;
        }
      }
      
      // Handle position updates
      function handlePositionUpdate(position) {
        currentPosition = position;
        updateStatusMessage(`GPS: ${position.coords.latitude.toFixed(6)}, ${position.coords.longitude.toFixed(6)}`);
        loadNearbyFlowers();
        updateCoordinatesDisplay();
      }
      
      // Update the coordinates display at the bottom of the screen
      function updateCoordinatesDisplay() {
        const coordsElement = document.getElementById('coordinates-display');
        if (!coordsElement) return;
        
        // Clear previous content
        coordsElement.innerHTML = '';
        
        // Add current position
        if (currentPosition) {
          const currentPosElement = document.createElement('div');
          currentPosElement.innerHTML = `<strong>Your Position:</strong> ${currentPosition.coords.latitude.toFixed(6)}, ${currentPosition.coords.longitude.toFixed(6)}, Alt: ${currentPosition.coords.altitude ? currentPosition.coords.altitude.toFixed(2) + 'm' : 'N/A'}`;
          coordsElement.appendChild(currentPosElement);
        }
        
        // Add flower positions
        if (anchoredObjects && anchoredObjects.length > 0) {
          const flowersList = document.createElement('div');
          flowersList.innerHTML = '<strong>Flower Locations:</strong> ';
          
          let count = 0;
          for (const obj of anchoredObjects) {
            if (obj.isGpsFlower && obj.gpsData) {
              count++;
              const flowerElement = document.createElement('div');
              flowerElement.textContent = `Flower ${count}: ${obj.gpsData.latitude.toFixed(6)}, ${obj.gpsData.longitude.toFixed(6)}`;
              flowersList.appendChild(flowerElement);
            }
          }
          
          if (count > 0) {
            coordsElement.appendChild(flowersList);
          }
        }
      }
      
      // Load nearby flowers based on current position
      async function loadNearbyFlowers() {
        if (!currentPosition) {
          console.log('[GPS] No position available yet');
          return;
        }
        
        try {
          // Get nearby flowers from server
          nearbyFlowers = await flowerDB.getNearbyFlowers(currentPosition, NEARBY_THRESHOLD);
          
          // Ensure nearbyFlowers is always an array
          if (!nearbyFlowers || !Array.isArray(nearbyFlowers)) {
            console.warn('[GPS] Server returned invalid data, using empty array');
            nearbyFlowers = [];
          }
          
          console.log(`[GPS] Found ${nearbyFlowers.length} nearby flowers`);
          
          // Update status with flower count
          updateStatusMessage(`GPS: ${currentPosition.coords.latitude.toFixed(6)}, ${currentPosition.coords.longitude.toFixed(6)} | Nearby flowers: ${nearbyFlowers.length}`);
          
          // Update the scene with the nearby flowers
          updateFlowersInScene();
        } catch (error) {
          console.error('[GPS] Error loading nearby flowers:', error);
          updateStatusMessage('Error loading nearby flowers. Check console for details.');
          // Ensure nearbyFlowers is an empty array on error
          nearbyFlowers = [];
        }
      }
      
      // Update the scene with nearby flowers
      function updateFlowersInScene() {
        // Clear existing GPS-based flowers (not user-placed ones)
        for (const obj of anchoredObjects) {
          if (obj.isGpsFlower) {
            scene.removeNode(obj.anchoredObject);
          }
        }
        
        // Filter to keep only user-placed flowers
        anchoredObjects = anchoredObjects.filter(obj => !obj.isGpsFlower);
        
        // Add nearby GPS flowers to the scene
        for (const flowerData of nearbyFlowers) {
          const flower = new Gltf2Node({url: 'media/gltf/sunflower/sunflower.gltf'});
          flower.scale = [0.3, 0.3, 0.3];
          
          // Set the matrix from stored data
          if (flowerData.matrix) {
            flower.matrix = new Float32Array(flowerData.matrix);
          }
          
          scene.addNode(flower);
          
          // Add to anchored objects with GPS flag
          anchoredObjects.push({
            anchoredObject: flower,
            anchor: null, // No XR anchor for GPS flowers
            isGpsFlower: true,
            gpsData: flowerData
          });
          
          // Update coordinates display when adding flowers
          updateCoordinatesDisplay();
        }
        
        console.log(`[GPS] Scene updated with ${nearbyFlowers.length} GPS flowers`);
      }
      
      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar')
              .then((supported) => {
                xrButton.enabled = supported;
              });
        }
        
        // Listen for drawing completion event
        document.addEventListener('drawingComplete', (event) => {
          console.log('Drawing completed, ready to place in AR');
          pendingDrawing = event.detail.drawingData;
          updateStatusMessage('Drawing ready! Tap to place it');
        });
      }

      function onRequestSession() {
        console.log("[DEBUG] Requesting AR session with hit-test and anchors");
        return navigator.xr.requestSession('immersive-ar', {requiredFeatures: ['local', 'hit-test', 'anchors']})
                           .then((session) => {
          console.log("[DEBUG] AR session created successfully");
          xrButton.setSession(session);
          onSessionStarted(session);
        }).catch(error => {
          console.error(`[DEBUG] Error creating AR session: ${error.message}`);
        });
      }

      function onSessionStarted(session) {
        console.log("[DEBUG] Session started");
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);

        // Add additional event listeners for better debugging
        session.addEventListener('inputsourceschange', (event) => {
          console.log(`[DEBUG] Input sources changed: ${event.added.length} added, ${event.removed.length} removed`);
        });

        if (!gl) {
          console.log("[DEBUG] Creating WebGL context");
          gl = createWebGLContext({
            xrCompatible: true
          });

          renderer = new Renderer(gl);
          console.log(`[DEBUG] Renderer created: ${renderer !== null}`);

          scene.setRenderer(renderer);
        }

        console.log("[DEBUG] Updating render state");
        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

        // In this sample we want to cast a ray straight out from the viewer's
        // position and render a reticle where it intersects with a real world
        // surface. To do this we first get the viewer space, then create a
        // hitTestSource that tracks it.
        console.log("[DEBUG] Requesting viewer reference space");
        session.requestReferenceSpace('viewer').then((refSpace) => {
          console.log("[DEBUG] Viewer reference space acquired");
          xrViewerSpace = refSpace;
          console.log("[DEBUG] Requesting hit test source");
          session.requestHitTestSource({ space: xrViewerSpace }).then((hitTestSource) => {
            console.log("[DEBUG] Hit test source acquired");
            xrHitTestSource = hitTestSource;
          }).catch(error => {
            console.error(`[DEBUG] Error creating hit test source: ${error.message}`);
          });
        }).catch(error => {
          console.error(`[DEBUG] Error getting viewer space: ${error.message}`);
        });

        console.log("[DEBUG] Requesting local reference space");
        session.requestReferenceSpace('local').then((refSpace) => {
          console.log("[DEBUG] Local reference space acquired");
          xrRefSpace = refSpace;

          session.requestAnimationFrame(onXRFrame);
        }).catch(error => {
          console.error(`[DEBUG] Error getting local space: ${error.message}`);
        });
      }

      function onEndSession(session) {
        // Use proper array methods instead of clear() which doesn't exist on arrays
        anchoredObjects = [];
        xrHitTestSource.cancel();
        xrHitTestSource = null;
        session.end();
      }

      function onSessionEnded(event) {
        xrButton.setSession(null);
      }

      const MAX_ANCHORED_OBJECTS = 30;
      let anchoredObjects = [];
      function addAnchoredObjectsToScene(anchor) {
        console.log("[DEBUG] Adding anchored flower to scene");
        let flower = new Gltf2Node({url: 'media/gltf/sunflower/sunflower.gltf'});
        flower.scale = [0.3, 0.3, 0.3]; // Increased scale to make flowers bigger
        scene.addNode(flower);
        anchoredObjects.push({
          anchoredObject: flower,
          anchor: anchor,
          isGpsFlower: false // This is a user-placed flower with XR anchor
        });

        console.log(`[DEBUG] Flower added, total anchored objects: ${anchoredObjects.length}`);

        // For performance reasons if we add too many objects start
        // removing the oldest ones to keep the scene complexity
        // from growing too much.
        if (anchoredObjects.length > MAX_ANCHORED_OBJECTS) {
          // Find the oldest non-GPS flower to remove
          const index = anchoredObjects.findIndex(obj => !obj.isGpsFlower);
          if (index !== -1) {
            let objectToRemove = anchoredObjects.splice(index, 1)[0];
            scene.removeNode(objectToRemove.anchoredObject);
            if (objectToRemove.anchor) {
              objectToRemove.anchor.delete();
            }
            console.log("[DEBUG] Removed oldest flower due to limit");
          }
        }
      }

      let rayOrigin = vec3.create();
      let rayDirection = vec3.create();
      function onSelect(event) {
        console.log("[DEBUG] onSelect called");
        console.log(`[DEBUG] Reticle visible: ${reticle.visible}`);

        if (reticle.visible) {
          console.log("[DEBUG] Creating anchor from hit test result");
          // Create an anchor.
          reticleHitTestResult.createAnchor().then(async (anchor) => {
            console.log("[DEBUG] Anchor created successfully");
            
            // Check if we have a pending drawing to place
            if (pendingDrawing) {
              console.log("[DEBUG] Placing drawing at hit location");
              
              // IMPORTANT: Always create and add the drawing node first, regardless of GPS
              // This ensures the drawing is visible in AR even without GPS
              const drawingNode = await addDrawingToScene(anchor, pendingDrawing);
              console.log("[DEBUG] Drawing node created:", drawingNode ? "success" : "failed");
              
              if (drawingNode) {
                console.log("[DEBUG] Drawing node added to scene successfully");
                
                // Try to save with GPS if available, but don't block placement
                try {
                  if (currentPosition) {
                    // If GPS is available, save with coordinates
                    const drawingData = {
                      latitude: currentPosition.coords.latitude,
                      longitude: currentPosition.coords.longitude,
                      altitude: currentPosition.coords.altitude || 0,
                      imageData: pendingDrawing,
                      timestamp: new Date().toISOString()
                    };
                    
                    // Save drawing to server
                    await saveDrawingToServer(drawingData);
                    console.log(`[GPS] Drawing saved at ${drawingData.latitude}, ${drawingData.longitude}`);
                    updateStatusMessage('Drawing placed and saved with GPS coordinates!');
                    
                    // Refresh nearby drawings (async)
                    await loadNearbyDrawings();
                  } else {
                    // No GPS, but drawing is already placed locally
                    console.log("[DEBUG] Drawing placed locally only (no GPS)");
                    updateStatusMessage('Drawing placed locally (GPS not available)');
                  }
                  
                  // Clear the pending drawing in either case
                  pendingDrawing = null;
                } catch (error) {
                  console.error('[DEBUG] Error handling drawing placement:', error);
                  updateStatusMessage('Drawing placed locally only.');
                  pendingDrawing = null;
                }
              } else {
                console.error("[DEBUG] Failed to create drawing node");
                updateStatusMessage("Error creating drawing. Please try again.");
                pendingDrawing = null; // Clear pending drawing on error
              }
            } else {
              // Check if GPS is available before placing a flower
              if (currentPosition) {
                // Save the flower with GPS coordinates to server
                const pose = reticleHitTestResult.getPose(xrRefSpace);
                try {
                  const flowerData = await flowerDB.saveFlower(currentPosition, Array.from(pose.transform.matrix));
                  console.log(`[GPS] Saved flower at ${flowerData.latitude}, ${flowerData.longitude}`);
                  updateStatusMessage(`Flower placed and saved to server!`);
                  updateCoordinatesDisplay();
                } catch (error) {
                  console.error('[GPS] Error saving flower to server:', error);
                  updateStatusMessage('Error saving flower to server. Placed locally only.');
                }
                
                // Add the flower to the scene as usual
                addAnchoredObjectsToScene(anchor);
              } else {
                console.log("[GPS] GPS not available, placing local flower only");
                updateStatusMessage("GPS not available, placing local flower only");
                
                // Add the flower to the scene as usual
                addAnchoredObjectsToScene(anchor);
              }
            }
          }).catch((error) => {
            console.error("[DEBUG] Could not create anchor: " + error);
            updateStatusMessage("Could not place object: " + error);
          });
        } else {
          console.log("[DEBUG] Reticle not visible, cannot place object");
          updateStatusMessage("Point at a surface to place an object");
        }
      }

      // Debug counter to track frame rendering
      let frameCounter = 0;
      let lastLogTime = 0;

      // Called every time a XRSession requests that a new frame be drawn.
      function onXRFrame(t, frame) {
        frameCounter++;

        // Log debug info every 60 frames (approximately once per second)
        const shouldLog = (t - lastLogTime) > 1000;
        if (shouldLog) {
          console.log(`[DEBUG] Frame ${frameCounter} at time ${t.toFixed(2)}ms`);
          lastLogTime = t;
        }

        let session = frame.session;
        let pose = frame.getViewerPose(xrRefSpace);

        // Debug pose information
        if (shouldLog) {
          console.log(`[DEBUG] Pose available: ${pose !== null}`);
          console.log(`[DEBUG] GL context lost: ${gl.isContextLost()}`);
          console.log(`[DEBUG] Anchored objects: ${anchoredObjects.length}`);
        }

        reticle.visible = false;

        // If we have a hit test source, get its results for the frame
        // and use the pose to display a reticle in the scene.
        if (xrHitTestSource && pose) {
          let hitTestResults = frame.getHitTestResults(xrHitTestSource);
          if (shouldLog) {
            console.log(`[DEBUG] Hit test results: ${hitTestResults.length}`);
          }

          if (hitTestResults.length > 0) {
            let pose = hitTestResults[0].getPose(xrRefSpace);
            reticle.visible = true;
            reticle.matrix = pose.transform.matrix;
            reticleHitTestResult = hitTestResults[0];

            if (shouldLog) {
              console.log(`[DEBUG] Reticle visible: ${reticle.visible}`);
              console.log(`[DEBUG] Reticle matrix: ${reticle.matrix[0].toFixed(2)},${reticle.matrix[5].toFixed(2)},${reticle.matrix[10].toFixed(2)}`);
            }
          }
        }

        // Debug tracked anchors
        if (shouldLog) {
          console.log(`[DEBUG] Tracked anchors: ${frame.trackedAnchors ? frame.trackedAnchors.size : 'N/A'}`);
        }

        for (const {anchoredObject, anchor} of anchoredObjects) {
          // only update the object's position if it's still in the list
          // of frame.trackedAnchors and the anchor is valid
          if (!frame.trackedAnchors || !anchor || !frame.trackedAnchors.has(anchor)) {
            continue;
          }
          const anchorPose = frame.getPose(anchor.anchorSpace, xrRefSpace);
          if (anchorPose) {
            anchoredObject.matrix = anchorPose.transform.matrix;
          } else if (shouldLog) {
            console.log(`[DEBUG] No anchor pose for tracked anchor`);
          }
        }

        scene.startFrame();

        // Debug rendering
        if (shouldLog) {
          console.log(`[DEBUG] Before drawXRFrame - renderer ready: ${renderer !== null}`);
        }

        session.requestAnimationFrame(onXRFrame);

        try {
          scene.drawXRFrame(frame, pose);
          if (shouldLog) {
            console.log(`[DEBUG] drawXRFrame completed successfully`);
          }
        } catch (error) {
          console.error(`[DEBUG] Error in drawXRFrame: ${error.message}`);
        }

        scene.endFrame();
      }

      // Add GPS controls to the header
      function addGpsControls() {
        const header = document.querySelector('header');
        
        // Create refresh button
        const refreshButton = document.createElement('button');
        refreshButton.textContent = 'Refresh GPS Flowers';
        refreshButton.addEventListener('click', () => {
          loadNearbyFlowers();
          updateStatusMessage('GPS flowers refreshed');
        });
        
        // Create draw button
        const drawButton = document.createElement('button');
        drawButton.textContent = 'Draw & Place';
        drawButton.addEventListener('click', () => {
          window.DrawingManager.showDrawingUI();
          updateStatusMessage('Drawing mode activated');
        });
        
        // Add buttons to header
        header.appendChild(refreshButton);
        header.appendChild(drawButton);
      }
      
      // Create a plane with the drawing texture
      async function createDrawingPlane(drawingData) {
        console.log("[DEBUG] createDrawingPlane called with data of length:", drawingData ? drawingData.length : 'null');
        
        // Validate drawing data early
        if (!drawingData || !drawingData.startsWith('data:image')) {
          console.error("[DEBUG] Invalid drawing data format:", drawingData ? drawingData.substring(0, 20) : 'null');
          updateStatusMessage("Error: Invalid drawing data format");
          return null; // Return null instead of an empty plane to clearly indicate failure
        }
        
        const plane = new Node();

        // Create a material for the drawing - using a simpler material approach
        const material = new Material();
        
        // Fix rendering order/layer issues
        material.depthTest = false; // Disable depth testing to ensure visibility
        material.blend = true; // Enable transparency
        material.blendFunc = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; // Use ONE for source factor
        material.cullMode = gl.NONE; // Don't cull any faces
        material.renderOrder = 1000; // High render order to ensure it renders on top
        
        // Set material properties for maximum visibility
        material.baseColorFactor = [1.0, 1.0, 1.0, 1.0]; // Full opacity
        material.metallicFactor = 0.0; // Non-metallic
        material.roughnessFactor = 1.0; // Fully rough
        material.emissiveFactor = [1.0, 1.0, 1.0]; // Maximum glow

        // Load the drawing image as a texture
        const texture = await new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            console.log("[DEBUG] Image loaded successfully, dimensions:", img.width, "x", img.height);
            const texture = new Texture(gl, { 
              image: img,
              format: gl.RGBA, // Use RGBA format
              generateMipmaps: true // Generate mipmaps for better rendering
            });
            resolve(texture);
          };
          img.onerror = (error) => {
            console.error("[DEBUG] Failed to load drawing image for texture:", error);
            resolve(null); // Resolve with null on error
          };
          img.src = drawingData;
        });

        if (!texture) {
          console.error("[DEBUG] Could not create texture from drawing data.");
          updateStatusMessage("Error: Could not create drawing texture");
          return null; // Return null instead of an empty plane to clearly indicate failure
        }

        console.log("[DEBUG] Texture created successfully");
        material.baseColorTexture = texture;

        // Create a simpler quad for the drawing
        const mesh = new Mesh(gl, {
          vertices: [
            -1.0, -1.0, 0.0,  // Bottom left
             1.0, -1.0, 0.0,  // Bottom right
             1.0,  1.0, 0.0,  // Top right
            -1.0,  1.0, 0.0,  // Top left
          ],
          texcoords: [
            0.0, 0.0,  // Bottom left
            1.0, 0.0,  // Bottom right
            1.0, 1.0,  // Top right
            0.0, 1.0,  // Top left
          ],
          normals: [
            0.0, 0.0, 1.0,  // All normals point forward
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
          ],
          indices: [0, 1, 2, 0, 2, 3],  // Two triangles forming a quad
          material: material,
        });

        // Create a parent node with proper transformation
        const drawingNode = new Node();
        drawingNode.addNode(mesh);
        
        // Add the drawing node to the plane
        plane.addNode(drawingNode);
        
        // Set renderOrder for the plane to ensure it renders on top
        plane.renderOrder = 1000;
        
        // Log success
        console.log("[DEBUG] Drawing plane created successfully with mesh and texture");

        return plane;
      }
      
      // Save drawing to server
      async function saveDrawingToServer(drawingData) {
        try {
          const response = await fetch(`${flowerDB.apiUrl}/drawings`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(drawingData)
          });
          
          if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
          }
          
          return await response.json();
        } catch (error) {
          console.error('Error saving drawing to server:', error);
          throw error;
        }
      }
      
      // Load nearby drawings based on current position
      async function loadNearbyDrawings() {
        if (!currentPosition) {
          console.log('[GPS] No position available yet for drawings');
          return;
        }
        
        try {
          const response = await fetch(
            `${flowerDB.apiUrl}/drawings/nearby?lat=${currentPosition.coords.latitude}&lng=${currentPosition.coords.longitude}&distance=${NEARBY_THRESHOLD}`
          );
          
          if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
          }
          
          nearbyDrawings = await response.json();
          console.log(`[GPS] Found ${nearbyDrawings.length} nearby drawings`);
          
          // Update the scene with the nearby drawings
          updateDrawingsInScene();
        } catch (error) {
          console.error('[GPS] Error loading nearby drawings:', error);
          nearbyDrawings = [];
        }
      }
      
      // Update the scene with nearby drawings
      async function updateDrawingsInScene() {
        // Clear existing GPS-based drawings
        for (const obj of anchoredObjects) {
          if (obj.isDrawing && obj.isGpsFlower) {
            scene.removeNode(obj.anchoredObject);
          }
        }
        
        // Filter to keep only non-drawing objects or user-placed drawings
        anchoredObjects = anchoredObjects.filter(obj => !obj.isDrawing || !obj.isGpsFlower);
        
        // Add nearby GPS drawings to the scene
        console.log(`[GPS] Adding ${nearbyDrawings.length} nearby drawings to scene`);
        
        // Process drawings one by one to avoid overwhelming the system
        for (const drawingData of nearbyDrawings) {
          try {
            const drawingNode = new Node();
            
            // Create drawing plane with async/await
            console.log('[GPS] Creating drawing plane for nearby drawing');
            const drawingPlane = await createDrawingPlane(drawingData.imageData);
            console.log('[GPS] Drawing plane created successfully');
            
            drawingPlane.scale = [0.2, 0.2, 0.2]; // Scale appropriately
            drawingNode.addNode(drawingPlane);
            scene.addNode(drawingNode);
            
            // Add to anchored objects
            anchoredObjects.push({
              anchoredObject: drawingNode,
              anchor: null, // No XR anchor for GPS-based drawings
              isDrawing: true,
              isGpsFlower: true // This is a GPS-based drawing
            });
          } catch (error) {
            console.error('[GPS] Error creating drawing plane for nearby drawing:', error);
          }
        }
        
        console.log(`[GPS] Scene updated with ${nearbyDrawings.length} GPS drawings`);
      }
      
      // Add event listener for drawing completion
      document.addEventListener('drawingComplete', (event) => {
        console.log('[DEBUG] Drawing complete event received');
        // Store the drawing data for placement
        pendingDrawing = event.detail.drawingData;
        
        // Log the drawing data to verify it's valid
        console.log('[DEBUG] Drawing data received:', pendingDrawing ? pendingDrawing.substring(0, 50) + '...' : 'null');
        
        // Notify user to place the drawing
        updateStatusMessage('Drawing ready! Point at a surface to place it.');
        
        // Log GPS status for debugging
        if (currentPosition) {
          console.log('[DEBUG] GPS is available for drawing placement');
        } else {
          console.log('[DEBUG] GPS is NOT available, but drawing will still be placed locally');
        }
      });
      
      // Function to add a drawing to the scene (similar to addAnchoredObjectsToScene)
      async function addDrawingToScene(anchor, drawingData) {
        console.log("[DEBUG] Adding anchored drawing to scene");
        
        try {
          // Create a drawing node
          const drawingNode = new Node();
          
          // Set high render order for the drawing node
          drawingNode.renderOrder = 2000;
          
          // Create a plane for the drawing
          const drawingPlane = await createDrawingPlane(drawingData);
          if (!drawingPlane) {
            console.error("[DEBUG] Failed to create drawing plane");
            return null;
          }
          
          console.log("[DEBUG] Drawing plane created successfully");
          
          // Make sure the drawing is visible and properly scaled
          drawingPlane.scale = [0.5, 0.5, 0.5]; // Increased scale for better visibility
          
          // Try a different orientation - no rotation
          // This will make the drawing appear flat on the surface
          
          // Add the drawing plane to the drawing node
          drawingNode.addNode(drawingPlane);
          
          // Add the drawing directly to the scene first for visibility testing
          scene.addNode(drawingNode);
          console.log("[DEBUG] Drawing node added to scene");
          
          // Create a simple colored cube as a test marker
          const testCube = new Mesh(gl, {
            vertices: [
              // Front face
              -0.1, -0.1,  0.1,
               0.1, -0.1,  0.1,
               0.1,  0.1,  0.1,
              -0.1,  0.1,  0.1,
              // Back face
              -0.1, -0.1, -0.1,
              -0.1,  0.1, -0.1,
               0.1,  0.1, -0.1,
               0.1, -0.1, -0.1,
            ],
            indices: [
              0, 1, 2,    0, 2, 3, // front
              4, 5, 6,    4, 6, 7, // back
              5, 3, 2,    5, 2, 6, // top
              4, 7, 1,    4, 1, 0, // bottom
              7, 6, 2,    7, 2, 1, // right
              4, 0, 3,    4, 3, 5  // left
            ],
            material: new Material({
              baseColorFactor: [1.0, 0.0, 0.0, 1.0], // Bright red
              depthTest: false, // Disable depth testing for visibility
              blend: true // Enable blending
            })
          });
          
          // Add the test cube to the drawing node
          const testNode = new Node();
          testNode.addNode(testCube);
          testNode.renderOrder = 3000; // Even higher render order
          drawingNode.addNode(testNode);
          console.log("[DEBUG] Test cube added to drawing node");
          
          // Add to anchored objects with specific type
          anchoredObjects.push({
            anchoredObject: drawingNode,
            anchor: anchor,
            isDrawing: true,
            isGpsFlower: false
          });
          
          console.log("[DEBUG] Drawing added to anchored objects array, total count:", anchoredObjects.length);
          console.log("[DEBUG] Drawing added to scene successfully with test cube");
          return drawingNode;
        } catch (error) {
          console.error("[DEBUG] Error adding drawing to scene:", error);
          updateStatusMessage('Error creating drawing. Please try again.');
          return null;
        }
      }

      // Start the application
      initXR();
      addGpsControls();
    </script>
  </body>
</html>